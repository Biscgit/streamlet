"""This module provides a Data class for handling nested dictionaries and lists."""

import operator
import typing
from collections.abc import MutableMapping
from datetime import datetime
from functools import reduce
from zoneinfo import ZoneInfo

import simplejson as json

from core.helpers import flatten
from core.settings import Settings

__all__ = ["Metric", "MetricFrame"]

if typing.TYPE_CHECKING:
    type T = object  # pylint: disable=C0103


class Metric(MutableMapping):
    """Data class to be generated by Inputs."""

    __slots__ = ("metric_frame", "metric", "metric_field_name", "attributes", "__frozen")

    METRIC_TYPES = (int, float, bool, complex)

    def __init__(self, frame: "MetricFrame", values, metric, metric_field):
        self.__frozen = False

        self.metric_frame = frame
        self.attributes: dict = values.copy()

        self.metric = metric
        self.metric_field_name: str | None = metric_field

        self.validate()

    def __repr__(self):
        return f"[{self.metric_frame.name}] {self.metric_field_name}: {self.metric}"

    def __getitem__(self, item: str):
        if item == self.metric_field_name:
            return self.metric

        return reduce(operator.getitem, item.split(Settings.nested_attr_seperator), self.attributes)

    def __setitem__(self, key, value):
        if self.__frozen:
            raise TypeError("Metric is frozen, changing values is not allowed!.")

        if key == self.metric_field_name:
            self.metric = value
        else:
            *path, field = key.split(Settings.nested_attr_seperator)
            top: dict = reduce(operator.getitem, path, self.attributes)
            top[field] = value

    def __delitem__(self, key):
        del self.attributes[key]

    def __setattr__(self, key, value):
        try:
            if self.__frozen:
                raise TypeError("Metric is frozen, changing values is not allowed!.")
        # fix issue when setting variable __frozen on __init__
        except AttributeError:
            pass

        super().__setattr__(key, value)

    def __or__(self, other):
        return dict(self) | other

    def __ior__(self, other):
        self.attributes |= other
        return self

    def __iter__(self):
        if self.metric_field_name:
            yield self.metric_field_name
        yield from self.flatten().keys()

    def __len__(self):
        return len(self.attributes)

    def validate(self):
        """Validates self for types and values."""
        _types = Metric.METRIC_TYPES

        if not isinstance(self.attributes, dict):
            raise TypeError("Attributes must be a dictionary.")
        try:
            json.dumps(self.attributes)
        except TypeError as e:
            raise ValueError("Attributes must be a JSON serializable.") from e

        if self.metric_field_name is None and not Settings.allow_none_metric:
            raise ValueError("Metric field cannot be None! If required, enable it in the settings.")

        if not (isinstance(self.metric, _types) or self.metric is None):
            msg = f"Metric data must be of one of types {_types}, not `{type(self.metric)}`."
            raise ValueError(msg)

    def flatten(self, mapping: dict | list = None) -> dict:
        """Flattens nested attribute dict on defined seperator."""
        return flatten(mapping or self.attributes, Settings.nested_attr_seperator)

    def freeze(self):
        """Freeze self."""
        self.__frozen = True


class MetricFrame(list[Metric]):
    """Wrapper for a list of Metrics"""

    __slots__ = ("creation_timestamp", "name")

    def __init__(self, name: str, ts: datetime = None, metrics: list[Metric] = None):
        super().__init__(metrics or [])
        self.name = name
        self.creation_timestamp = ts or datetime.now(ZoneInfo(Settings.timezone))

    def __getitem__(self, item):
        if isinstance(item, slice):
            return MetricFrame(self.name, self.creation_timestamp, super().__getitem__(item))
        return super().__getitem__(item)

    def freeze(self):
        """Freeze all metrics."""
        for metric in self:
            metric.freeze()

    def copy(self) -> "MetricFrame":
        return MetricFrame(self.name, self.creation_timestamp, super().copy())
